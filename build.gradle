plugins {
    id 'jacoco'
    id 'com.google.osdetector' version '1.7.3'
    id 'jvm-test-suite'
    id 'com.vanniktech.maven.publish' version '0.36.0' apply false
}

allprojects {
    repositories {
        mavenCentral()
    }
}

subprojects {
    group = 'io.spiffe'
    version = project.version

    ext {
        grpcVersion = '1.79.0'
        jupiterVersion = '5.13.4'
        mockitoVersion = '4.11.0'
        nimbusVersion = '10.7'
        shadowVersion = '9.0.0'

        //IMPORTANT: This must be in sync with the shaded netty version in gRPC
        nettyVersion = '4.2.9.Final'
    }

    apply plugin: 'java-library'
    apply plugin: 'jacoco'
    apply plugin: 'com.vanniktech.maven.publish'

    java {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
        withSourcesJar()
    }

    javadoc {
        exclude "**/grpc/**"
        exclude "**/internal/**"
    }

    // Central Portal + signing configuration
    mavenPublishing {
        // Credentials come from:
        //   - ORG_GRADLE_PROJECT_mavenCentralUsername
        //   - ORG_GRADLE_PROJECT_mavenCentralPassword
        publishToMavenCentral()
        signAllPublications()

        pom {
            name.set(project.name)
            url.set('https://github.com/spiffe/java-spiffe')

            if (project.description) {
                description.set(project.description)
            }

            scm {
                connection = 'scm:git:https://github.com/spiffe/java-spiffe.git'
                developerConnection = 'scm:git:git@github.com:spiffe/java-spiffe.git'
                url = 'https://github.com/spiffe/java-spiffe'
            }

            licenses {
                license {
                    name = 'The Apache License, Version 2.0'
                    url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                }
            }

            developers {
                ['maxlambrecht:Max Lambrecht', 'rturner3:Ryan Turner'].each { devData ->
                    developer {
                        def devInfo = devData.split(':')
                        id = devInfo[0]
                        name = devInfo[1]
                        url = 'https://github.com/' + devInfo[0]
                        roles = ["Maintainer"]
                    }
                }
            }
        }
    }

    dependencies {
        implementation "org.apache.commons:commons-lang3:3.20.0"
        implementation "commons-validator:commons-validator:1.10.1"

        testImplementation "org.junit.jupiter:junit-jupiter-api:${jupiterVersion}"
        testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${jupiterVersion}"
        testImplementation "org.junit.jupiter:junit-jupiter-params:${jupiterVersion}"

        testImplementation "org.mockito:mockito-core:${mockitoVersion}"
        testRuntimeOnly "org.mockito:mockito-junit-jupiter:${mockitoVersion}"

        if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
            testImplementation "uk.org.webcompere:system-stubs-core:2.0.3"
        } else {
            testImplementation "uk.org.webcompere:system-stubs-core:2.1.8"
        }
    }

    testing {
        suites {
            test {
                useJUnitJupiter()
            }
        }
    }

    plugins.withId('com.vanniktech.maven.publish') {
        tasks.matching { it.name == 'generateMetadataFileForMavenPublication' }.configureEach {
            dependsOn(
                    tasks.matching { it.name == 'plainJavadocJar' }
            )
        }
    }

    // Disable per-module JaCoCo reports; generate a single aggregate report at root
    tasks.withType(JacocoReport).configureEach {
        enabled = false
    }
}

tasks.register('jacocoTestReport', JacocoReport) {
    dependsOn(subprojects.collect { it.tasks.named('test') })

    jacocoClasspath = configurations.jacocoAnt

    executionData = fileTree(rootDir) {
        include '**/build/jacoco/*.exec'
        include '**/build/jacoco/*.ec'
    }

    def mainSourceDirs = files(subprojects.collect { p -> p.sourceSets.main.allSource.srcDirs })
    def mainClassDirs  = files(subprojects.collect { p -> p.sourceSets.main.output })

    sourceDirectories = mainSourceDirs

    classDirectories = files(mainClassDirs.files.collect { dir ->
        fileTree(dir: dir, exclude: [
                '**/grpc/**',
                '**/exception/**',
                '**/internal/**'
        ])
    })

    reports {
        xml.required = true
        html.required = true

        xml.outputLocation = layout.buildDirectory.file('reports/jacoco/jacoco.xml')
        html.outputLocation = layout.buildDirectory.dir('reports/jacoco/html')
    }
}

// copy submodules jars to a common folder for deploy
def copyJars = tasks.register('copyJars', Copy) {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    from(subprojects.collect { it.tasks.withType(Jar) })
    into(layout.buildDirectory.dir("libs"))
}

tasks.named('assemble') {
    finalizedBy(copyJars)
}
